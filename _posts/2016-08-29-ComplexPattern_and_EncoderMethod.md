---
layout: post
title: ComplexPattern and EncoderMethod
---
Some instruction is a little complicated because the pattern match is not a simple pattern and the type of operand is not straightforward.  
Here is an example. There are user defined operand, xmem and xaddr.   

``` C++
def INC8xm : II8<0x34, (outs), (ins xmem:$Imm),                                                                                                                                
        "inc\t{($Imm)}", [(store (add (i8 (load xaddr:$Imm)), 1), xaddr:$Imm)]>;
```

First, let dig the user defined operand, xaddr, in the pattern matching part.
It is defined as a ComplexPattern. The xaddr is a iPTR type and there is a tranforming function, SelectXAddr to translate the input to **2** outputs.  

``` C++
def xaddr : ComplexPattern<iPTR, 2, "SelectXAddr", [], []>;  
```

Here is the implementation of SelectXaddr. If the input operand can pass the pattern check, the function returns true and two SDValue are outputed, (Base, Disp). From the logic, we could find that two kinds of possible outputs are returned after the function, (TargetFraimeIndex, TargetConstant) and (TargetReg, TargetConstant) when the pattern is matched.   

``` C++
bool Z80DAGToDAGISel::SelectXAddr(SDValue N, SDValue &Base, SDValue &Disp)
{
  switch (N->getOpcode())
  {
  case ISD::FrameIndex:
    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(N))
    {   
      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
      Disp = CurDAG->getTargetConstant(0, MVT::i8);
      return true;
    }   
    break;
  case ISD::CopyFromReg:
    if (RegisterSDNode *RN = dyn_cast<RegisterSDNode>(N.getOperand(1)))
    {   
      unsigned Reg = RN->getReg();
      if (Reg == Z80::IX || Reg == Z80::IY)
      {   
        Base = N;
        Disp = CurDAG->getTargetConstant(0, MVT::i8);
        return true;
      }   
    }   
    break;
  case ISD::ADD:
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N.getOperand(1)))
    {   
      SDValue Op0 = N.getOperand(0);
      if (Op0.getOpcode() == ISD::CopyFromReg)                                                                                                                                       
      {   
        RegisterSDNode *RN = dyn_cast<RegisterSDNode>(Op0.getOperand(1));
        unsigned Reg = RN->getReg();
        if (Reg == Z80::IX || Reg == Z80::IY)
        {   
          Base = N.getOperand(0);
          Disp = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i8);
          return true;
        }   
      }   
      else if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Op0))
      {   
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i16);
        Disp = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i8);
        return true;
      }   
    }   
    break;
  }
  return false;
}
```

After the whole pattern matching is done (also include nested matching), lets go to the instruction encoding part.
Actually, xmem is represented by two operands, IR16 and i8imm. The encoding way is not straightforward, so setup a EncoderMethod, "getXMemOpValue," to do this.

``` C++
def xmem : Operand<i16> {                                                                                                                                                            
  let PrintMethod   = "printXMemOperand";
  let EncoderMethod = "getXMemOpValue";
  let MIOperandInfo = (ops IR16, i8imm);
}
```

Only i8imm part is expected to be returned by the EncoderMethod. Hence, only immediate operand is return for encoding when the first operand is a register and second one is a immediate. (The reason to do this is because of the backend design, but not mean that the instruction really don't need the register information. The register information is encoded by other way.)  
If you still follow, you should find that the outputs of pattern matching part, returned by SelectXAddr and the input of encoding part are consistent, both are (register, constant).     

``` C++
unsigned Z80MCCodeEmitter::getXMemOpValue(const MCInst &MI, unsigned OpNo,
  SmallVectorImpl<MCFixup> &Fixups) const
{ 
  const MCOperand &MOReg = MI.getOperand(OpNo);
  const MCOperand &MOImm = MI.getOperand(OpNo+1);
  if (MOReg.isReg() && MOImm.isImm())
      return static_cast<unsigned>(MOImm.getImm());
  return 0;                                                                                                                                                                          
}
```

The location where to call getXMemOpValue is as following. The code are generated by tablgen as it is expected.   

``` C++
uint64_t Z80MCCodeEmitter::getBinaryCodeForInstr(const MCInst &MI,
    SmallVectorImpl<MCFixup> &Fixups) const {
    .
    .
    .
    case Z80::INC8xm: {
      // op: Imm
      op = getXMemOpValue(MI, 0, Fixups);
      Value |= (op & UINT64_C(255)) << 8;
      break;
    }   
    .
    .
    .
```


